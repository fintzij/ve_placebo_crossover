---
title: "Assessing Vaccine Durability Following Placebo Crossover"
author: 
  - "Jon Fintzi and Dean Follmann"
  - "Biostatistics Research Branch, NIAID, NIH"
date: "12/28/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
```

```{r libraries, include = FALSE}
library(simsurv) # simulates data
library(survival)
library(tidyverse)
library(ggthemes)
library(knitr)
library(patchwork)
library(kableExtra)

rep_est = function(est, se, digs = 2) {
    res = vector("list", length(est))
    est_r = unname(round(est, digits = digs))
    ci_r = unname(round(cbind(est - 1.96 * se, est + 1.96 * se), digits = digs))
    
    for(s in seq_along(est)) {
        res[[s]] = 
            paste0(est_r[s], " (95% CI: ", ci_r[s,1], ", ", ci_r[s,2], ")")
    }
    
    return(unlist(res))
}
```

\newcommand{\btheta}{\boldsymbol{\theta}}
\newcommand{\btau}{\boldsymbol{\tau}}

# Overview

Randomized vaccine trials are used to assess vaccine efficacy and to characterize the durability of vaccine induced protection. There is a broad consensus that placebo volunteers in COVID-19 vaccine trials should be offered a vaccine once efficacy has been established. This will likely lead to most placebo volunteers crossing over to the vaccine arm, thus complicating the assessment of long term durability. 

In this vignette, we provide code for simulating COVID-19 vaccine trials and assessing vaccine efficacy (VE) and durability of vaccine induced protection within a Cox proportional hazards framework. The code supplied in this vignette reproduces the example trials in Fintzi and Follmann (2021), but is flexible and can be modified to accommodate staggered entry, frailties, waning or constant VE, and various study designs including placebo-crossover, continuous crossover, or standard parallel arm trials. Raw code reproducing the various simulations in the manuscript are provided in the following GitHub repository: (((()))). 

# Setup

We will simulate a COVID-19 vaccine trial where the true VE waned linearly on the log--hazard scale from 85% to 35% over 1.5 years. The trial enrolls 30,000 participants with linear accrual over three months in a 1:1 randomization to vaccine or placebo. The baseline attack rate is piece--wise constant, with change--points every three months, and is calibrated to yield 50, 75, 50, and 25 cases on the placebo arm in each period in the first year, and half the expected number of cases per period on the placebo arm in year two. In this example, interim analyses are planned at 150 cases, which ultimately result in crossover at the end of year one following evaluation and vetting of the efficacy by a regulatory agency. Placebo crossover occurs over a four week period. Each volunteer is followed for a total of two years. 

Let $t\geq 0$ index time since study initiation, and let $\btau = \left\lbrace\btau_i = \left(\tau_i^{(e)},\tau_i^{(v)}\right);  \tau_i^{(v)}\geq\tau_i^{(e)}>0,\ i=1,\dots,N\right\rbrace$ denote the times of study entry and vaccination for the study participants. Define $Z_i(t)$ to be an indicator for whether $t>\tau_i^{(v)}$. We will suppose that vaccine efficacy decays linearly on the log-hazard scale. The hazard for participant $i$ is, 
\begin{align}
    \label{eqn:loglin_decay_haz}
    h_i(t) &= \left\lbrace \begin{array}{ll}
         0 &,\ t\leq\tau_i^{(e)}, \\
         h_0(t)\exp\left[Z_i(t)\left(\theta_1 + \theta_2\left(t-\tau_i^{(v)}\right)\right) \right] &,\ t > \tau_i^{(e)}.
    \end{array} \right .
\end{align} 
Here, $VE(t) = 1 - \exp\left[\theta_1 + \theta_2\left(t - \tau^{(v)}\right)\right]$. The baseline hazards, $h_0(t) = \gamma_\ell,\ t \in
(t_{\ell-1}, t_\ell]$, are piecewise constant over three month periods,
$(t_0,t_1],\ (t_1,t_2],\dots,\ (t_7,t_8]$, and follow a seasonal pattern
calibrated so we have an average of 50 events on the placebo arm in the first three months, 75 in months 4-6, 50 in months 7-9, and 25 in months 10-12 of the first study year. The baseline hazards in the subsequent study year are halved.

We integrate the hazard and obtain the survival function. Event times can then be simulated via the inverse CDF method. This is facilitated via wrappers implemented in the `simsurv` package (Brilleman, 2019). 

# Functions to Simulate COVID-19 Trials

We implement the functions for simulating trials below. Note that these functions will do more than we need in this vignette, but are general purpose wrappers that cover all of the simulations and examples in the manuscript. We first implement a function that returns the cumulative hazard in a time-interval over which the hazards are homogeneous.

```{r c_haz_int_fcn, echo = TRUE}
# cumulative hazard in a time-homogeneous interval
c_haz_int = 
  function(lambda_t,        # baseline hazard
           t_l,             # left endpoint
           t_r,             # right endpoint
           trt,             # treatment indicator (0 if not yet vaccinated)
           VE_max = NULL,   # VE(0), theta_1
           VE_decay = NULL, # slope parameter, theta_2
           t_trt = NULL,    # vaccination time
           frailty = 1) {
  
  # cumulative hazard over any interval for unvaccinated, always
  if(trt == 0) {
    c_haz = frailty * lambda_t * (t_r - t_l)
  } else {
    if(VE_decay == 0) {
      c_haz = frailty * lambda_t * exp(VE_max) * (t_r - t_l)
    } else {
      c_haz = 
        frailty * lambda_t * exp(VE_max) / VE_decay * 
        (exp(VE_decay * (t_r - t_trt)) - exp(VE_decay * (t_l - t_trt)))
    }
  }
  return(c_haz)
}
```

We now define a wrapper that calculates the cumulative hazard for a period, (0,t], over which the hazard is time-varying by aggregating the contributions from piecewise-homogeneous intervals.

```{r c_haz_fcn, echo = TRUE}
# cumulative hazard function 
# t: vector of times
# x: matrix with covariates
# betas: vector with parameters
cumul_haz = function(t, x, betas, ...) {
  
  # initialize the hazard vector
  c_haz_t = rep(0.0, length(t))
  
  # get time when hazard starts accumulating
  tstart = max(betas[["t0"]], x[["entry"]])
  
  # baseline hazard intervals
  haz_ints = seq(0, 2.25, by=0.25)
  times = sort(c(unique(c(betas[["t0"]], x[["entry"]], x[["crossover"]],
                          haz_ints, t))))
  endpoints_l = head(times, length(times)-1)
  endpoints_r = tail(times, length(times)-1)
  
  # which intervals are contributing
  contribs = endpoints_l >= tstart & endpoints_r <= min(t, 2.25)
  
  # treatment indicators at left endpoints
  trt_inds = 
    ifelse((x[["trt"]] == 1 & endpoints_l >= x[["entry"]]) |
             (x[["trt"]] == 0 & endpoints_l >= x[["crossover"]]), 1, 0)
  
  # now compute the cumulative hazards
  for(s in seq_along(t)) {
    
    # initialize vector of cumulative hazards
    c_haz_ints_s = rep(0.0, length(endpoints_l))
    
    # compute the hazards for each interval
    for(i in seq_along(endpoints_l)) {
      if(contribs[i]) {
        
        # grab the baseline hazard
        lambda_t = 
          betas[[paste0("lambda_", 
                        findInterval(endpoints_l[i], 
                                     haz_ints, all.inside = T))]]
        
        # set time of treatment administration
        t_trt = ifelse(x[["trt"]] == 1, x[["entry"]], x[["crossover"]])
        
        # cumulative hazard contribution
        c_haz_ints_s[i] = 
          c_haz_int(lambda_t = lambda_t, 
                    t_l = endpoints_l[i],
                    t_r = endpoints_r[i], 
                    trt = trt_inds[i],
                    VE_max = betas[["VE_max"]],
                    VE_decay = betas[["VE_decay"]],
                    t_trt = t_trt,
                    frailty = x[["frailty"]])
      }
    }
    
    c_haz_t[s] = sum(c_haz_ints_s)
  }
  
  return(c_haz_t)
}
```

Finally, a wrapper for simulating a COVID-19 vaccine trial. 

```{r sim_one_fcn, echo = TRUE}
sim_one <- function(n,                 # number of participants
                    pars,              # vector of simulation parameters
                    cumul_haz,         # cumulative hazard function
                    n_cross,           # number of events to start crossover
                    t_cross,           # time of crossover
                    enrolldur = 12/52, # enrollment period
                    crossdur = 4/52,   # crossover period
                    pvacc = 0.5,       # probability of vaccination
                    frailty_pars = NULL) { # gamma frailty dist params
    
    if(!is.null(t_cross)) {
        
        # create a data frame with subject IDs and treatment indicators
        covars <- data.frame(id = seq_len(n),
                             trt = rbinom(n, 1, pvacc),
                             entry = runif(n, 0, enrolldur),
                             crossover = 0)
        
        if(!is.null(frailty_pars)) {
          covars$frailty = 
            rgamma(n, shape = gamma_pars[1], rate = gamma_pars[2])
        } else {
          covars$frailty = 1
        }
        
        # simulate crossover times for placebo group
        covars$crossover[covars$trt == 0] = 
            t_cross + runif(sum(covars$trt == 0), 1e-5, 1e-5 + crossdur)
        
        # simulate event times
        dat <- simsurv::simsurv(betas = c(pars, t0 = 0), 
                                x = covars,
                                cumhazard = cumul_haz,
                                maxt = 2.25,
                                rootfun = qlogis,
                                ids = covars$id,
                                idvar = "id")
        
        dat <- merge(covars, dat) %>% arrange(eventtime)
        
    } else if(!is.null(n_cross)) {
        
        # create a data frame with subject IDs and treatment indicators
        covars_1 <- data.frame(id = seq_len(n),
                               trt = rbinom(n, 1, pvacc),
                               entry = runif(n, 0, enrolldur),
                               crossover = Inf)
        
        if(!is.null(frailty_pars)) {
          covars$frailty = 
            rgamma(n, shape = gamma_pars[1], rate = gamma_pars[2])
        } else {
          covars$frailty = 1
        }
        
        # simulate event times
        dat_1 <- 
            simsurv::simsurv(betas = c(pars, t0 = 0),
                             x = covars_1,
                             cumhazard = cumul_haz,
                             maxt = 2.25,
                             rootfun = qlogis,
                             ids = covars_1$id,
                             idvar = "id")
        
        # sort by event times
        dat_1 <- dat_1 %>% arrange(eventtime)
        n_events = cumsum(dat_1$status)
        
        # grab the crossover time
        t_cross = dat_1$eventtime[n_events == n_cross][1]
        
        # cache the pre-crossover data
        dat_1 <- dat_1 %>% filter(dat_1$eventtime <= t_cross)
        dat_sim_1 = merge(covars_1, dat_1) %>%  arrange(eventtime)
        
        # subset to get covariates for next part of the simulation
        covars_2 = covars_1[!covars_1$id %in% dat_sim_1$id, ]
        
        # generate crossover times
        covars_2$crossover[covars_2$trt == 0] = 
            t_cross + runif(sum(covars_2$trt == 0), 1e-5, 1e-5 + crossdur)
        
        # keep simulating
        dat_2 <- 
            simsurv::simsurv(betas = c(pars, t0 = t_cross),
                             x = covars_2,
                             cumhazard = cumul_haz,
                             maxt = 2.25,
                             rootfun = qlogis,
                             ids = covars_2$id,
                             idvar = "id")
        
        # sort by event time
        dat_2 <- dat_2 %>% arrange(id)
        
        # merge covars_2 and dat_2
        dat_sim_2 = merge(covars_2, dat_2) %>% arrange(eventtime)
        
        # combine simulated datasets
        dat = rbind(dat_sim_1, dat_sim_2)
        dat = dat %>% arrange(eventtime)  
    }
    
    dat$id = seq_along(dat$id)
    
    # censor people at two years post-study entry
    cens_inds = dat$eventtime > (dat$entry + 2)
    dat$eventtime[cens_inds] = dat$entry[cens_inds] + 2
    dat$status[cens_inds] = 0
    
    return(dat)
}
```

We will also find it useful to have functions for censoring a trial at crossover and reshaping a simulated dataset to get it into start-stop format.

```{r misc_fcns, echo = TRUE}
# to censor people at crossover
cens_cross <- function(dat, n_cross, t_cross) {
    
    if(!is.null(n_cross)) {
        
        # get the crossover time
        t_cross = dat[n_cross, "eventtime"]
        
        # censor events after crossover
        dat$status[(n_cross + 1):nrow(dat)] = 0
        dat$eventtime[(n_cross + 1):nrow(dat)] = t_cross
        
        # get rid of the crossover indicator
        dat$crossover = NULL  
        
    } else {
        
        # get the crossover index
        cross_ind = which(dat[,"eventtime"] > t_cross)[1]
        
        # censor events after crossover
        dat$status[cross_ind:nrow(dat)] = 0
        dat$eventtime[cross_ind:nrow(dat)] = t_cross
        
        # get rid of the crossover indicator
        dat$crossover = NULL
    }
    
    # drop records where people were censored prior to entry
    dat <- subset(dat, eventtime > entry)
    
    # censor people at two years post-study entry
    cens_inds = dat$eventtime > (dat$entry + 2)
    dat$eventtime[cens_inds] = dat$entry[cens_inds] + 2
    dat$status[cens_inds] = 0
    
    # rename columns = 
    names(dat)[1:5] = c("id", "vacc", "tstart", "tstop", "status")
    
    return(dat)
}

reshape_dat <- function(dat, align_entry = FALSE) {
    
    # align times so that entry times correspond to time zero for each participant
    if(align_entry) {
        dat <- 
            dat %>% 
            group_by(id) %>% 
            mutate(crossover = ifelse(trt == 1, 0, crossover - entry),
                   eventtime = eventtime - entry) %>% 
            mutate(entry = 0) %>% 
            ungroup() %>% 
            as.data.frame()
    }
    
    # two rows for each placebo, one for each in the treatment arm
    dat_new <- 
        data.frame(id = unlist(mapply(rep, x = dat$id, 
                                      each = ifelse(dat$trt == 1, 1, 2))),
                   tstart = unlist(lapply(seq_len(nrow(dat)), 
                                          function(x) {
                                              if(dat$trt[x] == 1) {
                                                  dat$entry[x]  
                                              } else {
                                                  c(dat$entry[x], dat$crossover[x])
                                              }})),
                   tstop = NA,
                   status = NA,
                   assg = 0,
                   vacc = 0,
                   tvacc = 0)
    
    # fill out the interval endpoints and status
    tmax = max(dat$eventtime)
    for(s in seq_along(unique(dat_new$id))) {
        
        inds <- which(dat_new$id == dat$id[s])
        
        if(dat$trt[s] == 1) {
            
            dat_new$assg[inds] = 1
            dat_new$vacc[inds] = 1
            dat_new$tvacc[inds] = dat$entry[s]
            dat_new$tstop[inds] = dat$eventtime[s]
            dat_new$status[inds] = dat$status[s]
            
        } else {
            
            dat_new$assg[inds] = c(0,0)
            dat_new$vacc[inds] = c(0,1)
            dat_new$tvacc[inds] = c(dat$crossover[s], dat$crossover[s])
            
            if(dat$eventtime[s] < dat$crossover[s]) {
                
                dat_new$tstop[inds]  = c(dat$eventtime[s], NA)
                dat_new$status[inds] = c(dat$status[s], NA)
                
            } else {
                
                dat_new$tstop[inds] = c(dat$crossover[s], dat$eventtime[s])
                dat_new$status[inds] = c(0, dat$status[s])
            }
        }
    }
    
    dat_new = 
        dat_new[complete.cases(dat_new),] %>% 
        arrange(id, tstop)
    
    return(dat_new)
}
```

# Simulating a COVID-19 Vaccine Trial

Let's go ahead and simulate a trial. We'll set the parameters and RNG seed, then simulate a trial. 

```{r sim_trial, echo = TRUE, cache = TRUE}

# set up parameters
t_cross = 1    # time of crossover
n_cross = NULL # we're not crossing at some number of events, this is NULL

# To get the baseline hazards
# h = function(r) (pexp(0.5, r) * 1.5e4 - 50)^2
# optimize(h, interval = c(0, 1))

sim_pars_waning = 
    c(VE_max = log(1 - 0.85), # theta_1
      VE_decay = 0.977558,    # theta_2
      lambda_1 = 0.0134, # 50 / 3 months
      lambda_2 = 0.02,   # 75 / 3 months
      lambda_3 = 0.0134, # 50 / 3 months
      lambda_4 = 0.0067, # 25  / 3 months
      lambda_5 = 0.0067, # 25 / 3 months
      lambda_3 = 0.01,   # 37.5 / 3 months
      lambda_7 = 0.0067, # 25 / 3 months
      lambda_8 = 0.0033, # 12.5 / 3 mo
      lambda_9 = 0.0067) # 25 / 3 mo

# set.seed
set.seed(1834)

# simulate trial
sim_waning <- 
    sim_one(n = 3e4,
            pars = sim_pars_waning, 
            n_cross = n_cross,
            t_cross = t_cross,
            cumul_haz = cumul_haz)

```


# References

- Sam Brilleman (2019). simsurv: Simulate Survival Data. R package
  version 0.2.3. https://CRAN.R-project.org/package=simsurv
